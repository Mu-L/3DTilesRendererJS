import{p as F,k as f,i as U,V as S,n,Q as Z}from"./three.module-BB2USAyE.js";import{E as q,c as R,N as H,m as V,s as L,a as j,b as z}from"./EnvironmentControls-BSw-XyT-.js";import{E as k}from"./lil-gui.module.min-D95Toaa3.js";const m=new F,P=new F,M=new f,s=new f,D=new f,O=new f,p=new f,W=new f,w=new f,A=new f,h=new Z,N=new f,y=new f,G={},_=new U,b=new k,d=new S,C=new S,E=new S,I=400;class X extends q{get ellipsoid(){return this.tilesRenderer?this.tilesRenderer.ellipsoid:null}get tilesGroup(){return this.tilesRenderer?this.tilesRenderer.group:null}constructor(t=null,i=null,o=null,e=null){super(t,i,o),this._dragMode=0,this._rotationMode=0,this.maxZoom=.01,this.useFallbackPlane=!1,this.reorientOnDrag=!1,this.allowNegativeNearPlanes=!0,this.setTilesRenderer(e)}setScene(t){t===null&&this.tilesRenderer!==null?super.setScene(this.tilesRenderer.group):super.setScene(t)}getPivotPoint(t){const{camera:i,tilesGroup:o,ellipsoid:e}=this;return p.set(0,0,-1).transformDirection(i.matrixWorld),m.copy(o.matrixWorld).invert(),_.origin.copy(i.position),_.direction.copy(p),_.applyMatrix4(m),R(_,e,s),s.applyMatrix4(o.matrixWorld),(super.getPivotPoint(t)===null||t.distanceTo(_.origin)>s.distanceTo(_.origin))&&t.copy(s),t}getVectorToCenter(t){const{tilesGroup:i,camera:o}=this;return t.setFromMatrixPosition(i.matrixWorld).sub(o.position)}getDistanceToCenter(){return this.getVectorToCenter(s).length()}getUpDirection(t,i){const{tilesGroup:o,ellipsoid:e}=this;m.copy(o.matrixWorld).invert(),s.copy(t).applyMatrix4(m),e.getPositionToNormal(s,i),i.transformDirection(o.matrixWorld)}getCameraUpDirection(t){const{tilesGroup:i,ellipsoid:o,camera:e}=this;e.isOrthographicCamera?(this._getVirtualOrthoCameraPosition(s),m.copy(i.matrixWorld).invert(),s.applyMatrix4(m),o.getPositionToNormal(s,t),t.transformDirection(i.matrixWorld)):this.getUpDirection(e.position,t)}update(){if(!this.enabled||!this.tilesGroup||!this.camera)return;const{camera:t,tilesGroup:i,pivotMesh:o}=this;if(this._isNearControls()?this.scaleZoomOrientationAtEdges=this.zoomDelta<0:(this.state!==H&&this._dragMode!==1&&this._rotationMode!==1&&(o.visible=!1),this.scaleZoomOrientationAtEdges=!1),super.update(),t.isPerspectiveCamera){let e=this.getDistanceToCenter();const r=this._getMaxPerspectiveDistance();e>r&&(s.setFromMatrixPosition(i.matrixWorld).sub(t.position).normalize().multiplyScalar(-1),t.position.setFromMatrixPosition(i.matrixWorld).addScaledVector(s,r),t.updateMatrixWorld(),e=r)}this.updateCameraClipPlanes(t)}updateCameraClipPlanes(t){const{tilesGroup:i,ellipsoid:o}=this;if(t.isPerspectiveCamera){const e=s.setFromMatrixPosition(i.matrixWorld).sub(t.position).length(),r=Math.max(...o.radius),l=.25*r,a=n.clamp((e-r)/l,0,1),c=n.lerp(1,1e3,a);t.near=Math.max(c,e-r-l);const u=m.copy(i.matrixWorld).invert();M.copy(t.position).applyMatrix4(u),o.getPositionToCartographic(M,G);const x=Math.max(o.getPositionElevation(M),I),g=o.calculateHorizonDistance(G.lat,x);t.far=g*3+.1,t.updateProjectionMatrix()}else{this._getVirtualOrthoCameraPosition(t.position,t),t.updateMatrixWorld(),m.copy(t.matrixWorld).invert(),s.setFromMatrixPosition(i.matrixWorld).applyMatrix4(m);const e=-s.z;t.near=e-Math.max(...o.radius)*1.1,t.far=e+.1,!this.allowNegativeNearPlanes&&t.near<0&&(t.position.addScaledVector(p,t.near),t.far-=t.near,t.near=0),t.updateProjectionMatrix(),t.updateMatrixWorld()}}resetState(){super.resetState(),this._dragMode=0,this._rotationMode=0}_updatePosition(){if(this._dragMode===1||this._isNearControls()){this._dragMode=1;const{raycaster:t,camera:i,pivotPoint:o,pointerTracker:e,domElement:r,tilesGroup:l}=this,a=M,c=w;e.getCenterPoint(d),V(d.x,d.y,r,d),L(t,d,i),m.copy(l.matrixWorld).invert(),t.ray.applyMatrix4(m);const u=s.copy(o).applyMatrix4(m).length();b.radius.setScalar(u),i.isPerspectiveCamera?b.intersectRay(t.ray,s)||j(t.ray,u,s):R(t.ray,b,s),s.applyMatrix4(l.matrixWorld),D.setFromMatrixPosition(l.matrixWorld),a.subVectors(o,D).normalize(),c.subVectors(s,D).normalize(),h.setFromUnitVectors(c,a),z(D,h,P),i.matrixWorld.premultiply(P),i.matrixWorld.decompose(i.position,i.quaternion,s)}else{this._dragMode=-1;const{pointerTracker:t,rotationSpeed:i,camera:o,pivotMesh:e,tilesGroup:r,ellipsoid:l,domElement:a}=this;let c;if(o.isPerspectiveCamera){t.getCenterPoint(d),t.getPreviousCenterPoint(C),V(d.x,d.y,a,d),V(C.x,C.y,a,C),s.set(d.x,d.y,-1).unproject(o),M.set(C.x,C.y,-1).unproject(o),s.sub(M);const g=Math.max(...l.radius),v=this.getDistanceToCenter()-g,T=s.distanceTo(M)*v/o.near;c=7.5*1e-4*T/g}else c=n.mapLinear(o.zoom,this._getOrthographicTransitionZoom(),this._getMinOrthographicZoom(),.001,.005);t.getCenterPoint(d),t.getPreviousCenterPoint(C),E.subVectors(d,C).multiplyScalar(c);const u=-E.x*i,x=-E.y*i;D.setFromMatrixPosition(r.matrixWorld),W.set(1,0,0).transformDirection(o.matrixWorld),O.set(0,1,0).transformDirection(o.matrixWorld),h.setFromAxisAngle(W,x),o.quaternion.premultiply(h),z(D,h,P),o.matrixWorld.premultiply(P),h.setFromAxisAngle(O,u),o.quaternion.premultiply(h),z(D,h,P),o.matrixWorld.premultiply(P),o.matrixWorld.decompose(o.position,o.quaternion,s),e.visible=!1}this._alignCameraUp(this.up)}_updateRotation(...t){this._rotationMode===1||this._isNearControls()?(this._rotationMode=1,super._updateRotation(...t)):(this.pivotMesh.visible=!1,this._rotationMode=-1),this._alignCameraUp(this.up)}_updateZoom(){const{zoomDelta:t,ellipsoid:i,zoomSpeed:o,zoomPoint:e,camera:r,maxZoom:l}=this,a=n.clamp(n.mapLinear(Math.abs(t),0,20,0,1),0,1);if(this._isNearControls()||t>0){if(t<0&&(this.zoomPointSet||this._updateZoomPoint())){p.set(0,0,-1).transformDirection(r.matrixWorld).normalize(),y.copy(this.up).multiplyScalar(-1),this.getUpDirection(e,N);const c=n.clamp(n.mapLinear(-N.dot(y),1,.95,0,1),0,1),u=1-p.dot(y),x=r.isOrthographicCamera?.05:1,g=n.clamp(a*3,0,1);y.lerpVectors(p,y,c*u*x*g).normalize(),h.setFromUnitVectors(p,y),z(e,h,P),r.matrixWorld.premultiply(P),r.matrixWorld.decompose(r.position,r.quaternion,y),this.zoomDirection.subVectors(e,r.position).normalize()}super._updateZoom()}else if(r.isPerspectiveCamera){const c=this._getPerspectiveTransitionDistance(),u=this._getMaxPerspectiveDistance(),x=n.mapLinear(this.getDistanceToCenter(),c,u,0,1);this._tiltTowardsCenter(n.lerp(0,.4,x*a)),this._alignCameraUpToNorth(n.lerp(0,.2,x*a));const g=this.getDistanceToCenter()-i.radius.x,v=t*g*o*.0025;this.getVectorToCenter(s).normalize(),this.camera.position.addScaledVector(s,v),this.camera.updateMatrixWorld(),this.zoomDelta=0}else{const c=this._getOrthographicTransitionZoom(),u=this._getMinOrthographicZoom(),x=n.mapLinear(r.zoom,c,u,0,1);this._tiltTowardsCenter(n.lerp(0,.4,x*a)),this._alignCameraUpToNorth(n.lerp(0,.2,x*a));const g=this.zoomDelta,v=Math.pow(.95,Math.abs(g*.05)),T=g>0?1/Math.abs(v):v;r.zoom=Math.max(this._getMinOrthographicZoom(),Math.min(l,r.zoom*T*o)),r.updateProjectionMatrix(),this.zoomDelta=0,this.zoomDirectionSet=!1}}_alignCameraUpToNorth(t){const{tilesGroup:i}=this;A.set(0,0,1).transformDirection(i.matrixWorld),this._alignCameraUp(A,t)}_alignCameraUp(t,i=null){const{camera:o}=this;p.set(0,0,-1).transformDirection(o.matrixWorld),W.set(-1,0,0).transformDirection(o.matrixWorld),w.crossVectors(t,p),i===null&&(i=1-Math.abs(p.dot(t)),i=n.mapLinear(i,0,1,-.01,1),i=n.clamp(i,0,1)**2),w.lerp(W,1-i).normalize(),h.setFromUnitVectors(W,w),o.quaternion.premultiply(h),o.updateMatrixWorld()}_tiltTowardsCenter(t){const{camera:i,tilesGroup:o}=this;p.set(0,0,-1).transformDirection(i.matrixWorld).normalize(),s.setFromMatrixPosition(o.matrixWorld).sub(i.position).normalize(),s.lerp(p,1-t).normalize(),h.setFromUnitVectors(p,s),i.quaternion.premultiply(h),i.updateMatrixWorld()}_getPerspectiveTransitionDistance(){const{camera:t,ellipsoid:i}=this;if(!t.isPerspectiveCamera)throw new Error;const o=Math.max(...i.radius),e=2*Math.atan(Math.tan(n.DEG2RAD*t.fov*.5)*t.aspect),r=o/Math.tan(n.DEG2RAD*t.fov*.5),l=o/Math.tan(e*.5);return Math.max(r,l)}_getMaxPerspectiveDistance(){const{camera:t,ellipsoid:i}=this;if(!t.isPerspectiveCamera)throw new Error;const o=Math.max(...i.radius),e=2*Math.atan(Math.tan(n.DEG2RAD*t.fov*.5)*t.aspect),r=o/Math.tan(n.DEG2RAD*t.fov*.5),l=o/Math.tan(e*.5);return 2*Math.max(r,l)}_getOrthographicTransitionZoom(){const{camera:t,ellipsoid:i}=this;if(!t.isOrthographicCamera)throw new Error;const o=t.top-t.bottom,e=t.right-t.left,r=Math.max(o,e),a=2*Math.max(...i.radius);return 2*r/a}_getMinOrthographicZoom(){const{camera:t,ellipsoid:i}=this;if(!t.isOrthographicCamera)throw new Error;const o=t.top-t.bottom,e=t.right-t.left,r=Math.min(o,e),a=2*Math.max(...i.radius);return .5*r/a}_getVirtualOrthoCameraPosition(t,i=this.camera){const{tilesGroup:o,ellipsoid:e}=this;if(!i.isOrthographicCamera)throw new Error;m.copy(o.matrixWorld).invert(),_.origin.copy(i.position),_.direction.set(0,0,-1).transformDirection(i.matrixWorld),_.applyMatrix4(m),R(_,e,M),M.applyMatrix4(o.matrixWorld);const r=i.top-i.bottom,l=i.right-i.left,a=Math.max(r,l)/i.zoom;p.set(0,0,-1).transformDirection(i.matrixWorld);const c=M.sub(i.position).dot(p);t.copy(i.position).addScaledVector(p,c-a*4)}_isNearControls(){const{camera:t}=this;return t.isPerspectiveCamera?this.getDistanceToCenter()<this._getPerspectiveTransitionDistance():t.zoom>this._getOrthographicTransitionZoom()}}export{X as G};
