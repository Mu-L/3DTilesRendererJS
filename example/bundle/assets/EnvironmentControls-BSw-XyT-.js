import{g as ot,az as nt,b as rt,V as x,p as et,i as at,k as f,j as it,E as ct,R as lt,Q as st,n as ht}from"./three.module-BB2USAyE.js";class pt extends ot{constructor(){super(new nt(0,0),new dt),this.renderOrder=1/0}onBeforeRender(t){const e=this.material.uniforms;t.getSize(e.resolution.value)}updateMatrixWorld(){this.matrixWorld.makeTranslation(this.position)}dispose(){this.geometry.dispose(),this.material.dispose()}}class dt extends rt{constructor(){super({depthWrite:!1,depthTest:!1,transparent:!0,uniforms:{resolution:{value:new x},size:{value:15},thickness:{value:2},opacity:{value:1}},vertexShader:`

				uniform float pixelRatio;
				uniform float size;
				uniform float thickness;
				uniform vec2 resolution;
				varying vec2 vUv;

				void main() {

					vUv = uv;

					float aspect = resolution.x / resolution.y;
					vec2 offset = uv * 2.0 - vec2( 1.0 );
					offset.y *= aspect;

					vec4 screenPoint = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
					screenPoint.xy += offset * ( size + thickness ) * screenPoint.w / resolution.x;

					gl_Position = screenPoint;

				}
			`,fragmentShader:`

				uniform float size;
				uniform float thickness;
				uniform float opacity;

				varying vec2 vUv;
				void main() {

					float ht = 0.5 * thickness;
					float planeDim = size + thickness;
					float offset = ( planeDim - ht - 2.0 ) / planeDim;
					float texelThickness = ht / planeDim;

					vec2 vec = vUv * 2.0 - vec2( 1.0 );
					float dist = abs( length( vec ) - offset );
					float fw = fwidth( dist ) * 0.5;
					float a = smoothstep( texelThickness - fw, texelThickness + fw, dist );

					gl_FragColor = vec4( 1, 1, 1, opacity * ( 1.0 - a ) );

				}
			`})}}class ut{constructor(){this.domElement=null,this.buttons=0,this.pointerType=null,this.pointerOrder=[],this.previousPositions={},this.pointerPositions={},this.startPositions={},this.pointerSetThisFrame={},this.hoverPosition=new x,this.hoverSet=!1}reset(){this.buttons=0,this.pointerType=null,this.pointerOrder=[],this.previousPositions={},this.pointerPositions={},this.startPositions={},this.pointerSetThisFrame={},this.hoverPosition=new x,this.hoverSet=!1}updateFrame(){const{previousPositions:t,pointerPositions:e}=this;for(const i in e)t[i].copy(e[i])}setHoverEvent(t){t.pointerType==="mouse"&&(this.getAdjustedPointer(t,this.hoverPosition),this.hoverSet=!0)}getLatestPoint(t){return this.pointerType!==null?(this.getCenterPoint(t),t):this.hoverSet?(t.copy(this.hoverPosition),t):null}getAdjustedPointer(t,e){const s=(this.domElement?this.domElement:t.target).getBoundingClientRect(),c=t.clientX-s.left,a=t.clientY-s.top;e.set(c,a)}addPointer(t){const e=t.pointerId,i=new x;this.getAdjustedPointer(t,i),this.pointerOrder.push(e),this.pointerPositions[e]=i,this.previousPositions[e]=i.clone(),this.startPositions[e]=i.clone(),this.getPointerCount()===1&&(this.pointerType=t.pointerType,this.buttons=t.buttons)}updatePointer(t){const e=t.pointerId;return e in this.pointerPositions?(this.getAdjustedPointer(t,this.pointerPositions[e]),!0):!1}deletePointer(t){const e=t.pointerId,i=this.pointerOrder;i.splice(i.indexOf(e),1),delete this.pointerPositions[e],delete this.previousPositions[e],delete this.startPositions[e],this.getPointerCount.length===0&&(this.buttons=0,this.pointerType=null)}getPointerCount(){return this.pointerOrder.length}getCenterPoint(t,e=this.pointerPositions){const i=this.pointerOrder;if(this.getPointerCount()===1||this.getPointerType()==="mouse"){const s=i[0];return t.copy(e[s]),t}else if(this.getPointerCount()===2){const s=this.pointerOrder[0],c=this.pointerOrder[1],a=e[s],l=e[c];return t.addVectors(a,l).multiplyScalar(.5),t}return null}getPreviousCenterPoint(t){return this.getCenterPoint(t,this.previousPositions)}getStartCenterPoint(t){return this.getCenterPoint(t,this.startPositions)}getPointerDistance(t=this.pointerPositions){if(this.getPointerCount()<=1||this.getPointerType()==="mouse")return 0;const{pointerOrder:e}=this,i=e[0],s=e[1],c=t[i],a=t[s];return c.distanceTo(a)}getPreviousPointerDistance(){return this.getPointerDistance(this.previousPositions)}getStartPointerDistance(){return this.getPointerDistance(this.startPositions)}getPointerType(){return this.pointerType}isPointerTouch(){return this.getPointerType()==="touch"}getPointerButtons(){return this.buttons}isLeftClicked(){return!!(this.buttons&1)}isRightClicked(){return!!(this.buttons&2)}}const C=new et,G=new at,N=new f;function U(p,t,e){return e.makeTranslation(-p.x,-p.y,-p.z),C.makeRotationFromQuaternion(t),e.premultiply(C),C.makeTranslation(p.x,p.y,p.z),e.premultiply(C),e}function b(p,t,e,i){i.x=(p-e.offsetLeft)/e.clientWidth*2-1,i.y=-((t-e.offsetTop)/e.clientHeight)*2+1,i.isVector3&&(i.z=0)}function vt(p,t,e){return t.intersectRay(p,e)?e:(C.makeScale(...t.radius).invert(),G.copy(p).applyMatrix4(C),N.set(0,0,0),G.closestPointToPoint(N,e).normalize(),C.makeScale(...t.radius),e.applyMatrix4(C))}function yt(p,t,e){const i=p.origin.length(),s=Math.acos(t/i);e.copy(p.origin).multiplyScalar(-1).normalize();const c=N.crossVectors(e,p.direction).normalize();e.multiplyScalar(-1).applyAxisAngle(c,-s).normalize().multiplyScalar(t)}function E(p,t,e){const{origin:i,direction:s}=p.ray;i.set(t.x,t.y,-1).unproject(e),s.set(t.x,t.y,0).unproject(e).sub(i).normalize(),p.camera=e}const _=0,R=1,w=2,A=3,W=4,V=.05,H=.025,M=new et,Q=new f,y=new f,F=new f,Y=new f,T=new f,z=new st,X=new it,S=new f,I=new f,j=new f,mt=new st,L=new x,d=new x,$=new x,Z=new x,B=new x,J=new x,ft={type:"change"},K={type:"start"},tt={type:"end"};class gt extends ct{get enabled(){return this._enabled}set enabled(t){t!==this.enabled&&(this.resetState(),this.pointerTracker.reset(),this._enabled=t)}constructor(t=null,e=null,i=null,s=null){super(),this.domElement=null,this.camera=null,this.scene=null,this.tilesRenderer=null,this._enabled=!0,this.cameraRadius=5,this.rotationSpeed=1,this.minAltitude=0,this.maxAltitude=.45*Math.PI,this.minDistance=10,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.zoomSpeed=1,this.adjustHeight=!0,this.reorientOnDrag=!0,this.scaleZoomOrientationAtEdges=!1,this.state=_,this.pointerTracker=new ut,this.needsUpdate=!1,this.actionHeightOffset=0,this.pivotPoint=new f,this.zoomDirectionSet=!1,this.zoomPointSet=!1,this.zoomDirection=new f,this.zoomPoint=new f,this.zoomDelta=0,this.pivotMesh=new pt,this.pivotMesh.raycast=()=>{},this.pivotMesh.scale.setScalar(.25),this.raycaster=new lt,this.raycaster.firstHitOnly=!0,this.up=new f(0,1,0),this.fallbackPlane=new it(new f(0,1,0),0),this.useFallbackPlane=!0,this._detachCallback=null,this._upInitialized=!1,this._lastUsedState=_,this._zoomPointWasSet=!1,this._tilesOnChangeCallback=()=>this.zoomPointSet=!1,i&&this.attach(i),e&&this.setCamera(e),t&&this.setScene(t),s&&this.setTilesRenderer(s)}setScene(t){this.scene=t}setCamera(t){this.camera=t,this._upInitialized=!1,this.zoomDirectionSet=!1,this.zoomPointSet=!1,this.needsUpdate=!0,this.resetState()}setTilesRenderer(t){this.tilesRenderer&&this.tilesRenderer.removeEventListener("tile-visibility-change",this._tilesOnChangeCallback),this.tilesRenderer=t,this.tilesRenderer!==null&&(this.tilesRenderer.addEventListener("tile-visibility-change",this._tilesOnChangeCallback),this.scene===null&&this.setScene(this.tilesRenderer.group))}attach(t){if(this.domElement)throw new Error("EnvironmentControls: Controls already attached to element");this.domElement=t,this.pointerTracker.domElement=t,t.style.touchAction="none";let e=!1;const i=o=>{o.preventDefault()},s=o=>{o.key==="Shift"&&(e=!0)},c=o=>{o.key==="Shift"&&(e=!1)},a=o=>{o.preventDefault();const{camera:n,raycaster:h,domElement:P,up:k,pivotMesh:D,pointerTracker:v}=this;if(v.addPointer(o),this.needsUpdate=!0,v.isPointerTouch()){if(D.visible=!1,v.getPointerCount()===0)P.setPointerCapture(o.pointerId);else if(v.getPointerCount()>2){this.resetState();return}}v.getCenterPoint(d),b(d.x,d.y,P,d),E(h,d,n);const q=Math.abs(h.ray.direction.dot(k));if(q<V||q<H)return;const O=this._raycast(h);O&&(v.getPointerCount()===2||v.isRightClicked()||v.isLeftClicked()&&e?(this.setState(v.isPointerTouch()?W:w),this.pivotPoint.copy(O.point),this.pivotMesh.position.copy(O.point),this.pivotMesh.updateMatrixWorld(),this.scene.add(this.pivotMesh)):v.isLeftClicked()&&(this.setState(R),this.pivotPoint.copy(O.point),this.pivotMesh.position.copy(O.point),this.pivotMesh.updateMatrixWorld(),this.scene.add(this.pivotMesh)))};let l=!1;const u=o=>{o.preventDefault(),this.zoomDirectionSet=!1,this.zoomPointSet=!1,this.needsUpdate=!0;const{pointerTracker:n}=this;n.setHoverEvent(o),n.updatePointer(o)&&n.isPointerTouch()&&n.getPointerCount()===2&&(l||(l=!0,queueMicrotask(()=>{l=!1,n.getCenterPoint(B);const h=n.getStartPointerDistance(),P=n.getPointerDistance(),k=P-h;if(this.state===_||this.state===W){n.getCenterPoint(B),n.getStartCenterPoint(J);const D=2*window.devicePixelRatio,v=B.distanceTo(J);(Math.abs(k)>D||v>D)&&(Math.abs(k)>v?(this.setState(A),this.zoomDirectionSet=!1):this.setState(w))}if(this.state===A){const D=n.getPreviousPointerDistance();this.zoomDelta+=P-D}else this.state===w&&(this.pivotMesh.visible=!0)})))},r=o=>{const{pointerTracker:n}=this;n.deletePointer(o),n.getPointerType()==="touch"&&n.getPointerCount()===0&&t.releasePointerCapture(o.pointerId),this.resetState(),this.needsUpdate=!0},m=o=>{o.preventDefault();const{pointerTracker:n}=this;n.setHoverEvent(o),n.updatePointer(o),this.dispatchEvent(K);let h;switch(o.deltaMode){case 2:h=o.deltaY*100;break;case 1:h=o.deltaY*16;break;case 0:h=o.deltaY;break}const P=Math.sign(h),k=Math.log(Math.abs(h)+1);this.zoomDelta-=3*P*k,this.needsUpdate=!0,this._lastUsedState=A,this.dispatchEvent(tt)},g=o=>{const{pointerTracker:n}=this;e=!1,o.buttons!==n.getPointerButtons()&&(n.deletePointer(o),this.resetState())};t.addEventListener("contextmenu",i),t.addEventListener("keydown",s),t.addEventListener("keyup",c),t.addEventListener("pointerdown",a),t.addEventListener("pointermove",u),t.addEventListener("pointerup",r),t.addEventListener("wheel",m),t.addEventListener("pointerenter",g),this._detachCallback=()=>{t.removeEventListener("contextmenu",i),t.removeEventListener("keydown",s),t.removeEventListener("keyup",c),t.removeEventListener("pointerdown",a),t.removeEventListener("pointermove",u),t.removeEventListener("pointerup",r),t.removeEventListener("wheel",m),t.removeEventListener("pointerenter",g)}}getUpDirection(t,e){e.copy(this.up)}getCameraUpDirection(t){this.getUpDirection(this.camera.position,t)}getPivotPoint(t){return this._lastUsedState===A?this._zoomPointWasSet?(t.copy(this.zoomPoint),t):null:this._lastUsedState===w||this._lastUsedState===R?(t.copy(this.pivotPoint),t):null}detach(){this.domElement=null,this._detachCallback&&(this._detachCallback(),this._detachCallback=null,this.pointerTracker.reset())}resetState(){this.state!==_&&this.dispatchEvent(tt),this.state=_,this.pivotMesh.removeFromParent(),this.pivotMesh.visible=!0,this.actionHeightOffset=0}setState(t=this.state,e=!0){this.state!==t&&(this.state===_&&e&&this.dispatchEvent(K),this.state=t,t!==_&&t!==W&&(this._lastUsedState=t))}update(){if(!this.enabled||!this.camera)return;const{camera:t,cameraRadius:e,pivotPoint:i,up:s,state:c,adjustHeight:a}=this;if(this.needsUpdate){const r=c,m=this.zoomDelta;r===R&&this._updatePosition(),r===w&&this._updateRotation(),(r===A||m!==0)&&this._updateZoom(),(r!==_||m!==0)&&this.dispatchEvent(ft),this.needsUpdate=!1}const l=t.isOrthographicCamera?null:a&&this._getPointBelowCamera()||null,u=t.isOrthographicCamera?i:l&&l.point||null;if(this.getCameraUpDirection(S),this._upInitialized?this._setFrame(S,u):(this._upInitialized=!0,this.up.copy(S)),(this.state===R||this.state===w)&&this.actionHeightOffset!==0){const{actionHeightOffset:r}=this;t.position.addScaledVector(s,-r),i.addScaledVector(s,-r),l&&(l.distance-=r)}if(this.actionHeightOffset=0,l){const r=l.distance;if(r<e){const m=e-r;t.position.addScaledVector(s,m),i.addScaledVector(s,m),this.actionHeightOffset=m}}this.pointerTracker.updateFrame()}dispose(){this.detach()}_updateZoom(){const{zoomPoint:t,zoomDirection:e,camera:i,minDistance:s,maxDistance:c,raycaster:a,pointerTracker:l,domElement:u,minZoom:r,maxZoom:m,zoomSpeed:g}=this;let o=this.zoomDelta;if(this.zoomDelta=0,!!l.getLatestPoint(d))if(i.isOrthographicCamera)if(b(d.x,d.y,u,I),E(a,d,i),e.copy(a.ray.direction).normalize(),this.zoomDirectionSet=!0,this.zoomPointSet||this._updateZoomPoint()){I.unproject(i);const n=Math.pow(.95,Math.abs(o*.05)),h=o>0?1/Math.abs(n):n;i.zoom=Math.max(r,Math.min(m,i.zoom*h*g)),i.updateProjectionMatrix(),b(d.x,d.y,u,j),j.unproject(i),i.position.sub(j).add(I),i.updateMatrixWorld()}else{const n=Math.pow(.95,Math.abs(o*.05)),h=o>0?1/Math.abs(n):n;i.zoom=Math.max(r,Math.min(m,i.zoom*h*g)),i.updateProjectionMatrix()}else{b(d.x,d.y,u,d),E(a,d,i),e.copy(a.ray.direction).normalize(),this.zoomDirectionSet=!0;const n=y.copy(e);if(this.zoomPointSet||this._updateZoomPoint()){const h=t.distanceTo(i.position);if(o<0){const P=Math.min(0,h-c);o=o*h*g*.0025,o=Math.max(o,P)}else{const P=Math.max(0,h-s);o=o*(h-s)*g*.0025,o=Math.min(o,P)}i.position.addScaledVector(e,o),i.updateMatrixWorld()}else{const h=this._getPointBelowCamera();if(h){const P=h.distance;n.set(0,0,-1).transformDirection(i.matrixWorld),i.position.addScaledVector(n,o*P*.01),i.updateMatrixWorld()}}}}_updateZoomPoint(){const{camera:t,zoomDirectionSet:e,zoomDirection:i,raycaster:s,zoomPoint:c,pointerTracker:a,domElement:l}=this;if(this._zoomPointWasSet=!1,!e)return!1;t.isOrthographicCamera&&a.getLatestPoint(L)?(b(L.x,L.y,l,L),E(s,L,t)):(s.ray.origin.copy(t.position),s.ray.direction.copy(i));const u=this._raycast(s);return u?(c.copy(u.point),this.zoomPointSet=!0,this._zoomPointWasSet=!0,!0):!1}_getPointBelowCamera(){const{camera:t,raycaster:e,up:i}=this;e.ray.direction.copy(i).multiplyScalar(-1),e.ray.origin.copy(t.position).addScaledVector(i,1e5);const s=this._raycast(e);return s&&(s.distance-=1e5),s}_updatePosition(){const{raycaster:t,camera:e,pivotPoint:i,up:s,pointerTracker:c,domElement:a}=this;if(c.getCenterPoint(d),b(d.x,d.y,a,d),X.setFromNormalAndCoplanarPoint(s,i),E(t,d,e),Math.abs(t.ray.direction.dot(s))<V){const l=Math.acos(V);T.crossVectors(t.ray.direction,s).normalize(),t.ray.direction.copy(s).applyAxisAngle(T,l).multiplyScalar(-1)}if(this.getUpDirection(i,S),Math.abs(t.ray.direction.dot(S))<H){const l=Math.acos(H);T.crossVectors(t.ray.direction,S).normalize(),t.ray.direction.copy(S).applyAxisAngle(T,l).multiplyScalar(-1)}t.ray.intersectPlane(X,y)&&(Q.subVectors(i,y),this.camera.position.add(Q),this.camera.updateMatrixWorld())}_updateRotation(){const{camera:t,pivotPoint:e,minAltitude:i,maxAltitude:s,pointerTracker:c,rotationSpeed:a,domElement:l}=this;c.getCenterPoint(d),c.getPreviousCenterPoint($),Z.subVectors(d,$).multiplyScalar(2*Math.PI/l.clientHeight);const u=-Z.x*a;let r=Z.y*a;F.set(0,0,-1).transformDirection(t.matrixWorld).multiplyScalar(-1),this.getUpDirection(e,S),y.crossVectors(S,F).normalize(),Y.set(1,0,0).transformDirection(t.matrixWorld).normalize();const g=Math.sign(y.dot(Y))*S.angleTo(F);r>0?(r=Math.min(g-i-.01,r),r=Math.max(0,r)):(r=Math.max(g-s,r),r=Math.min(0,r)),z.setFromAxisAngle(S,u),U(e,z,M),t.matrixWorld.premultiply(M),T.set(-1,0,0).transformDirection(t.matrixWorld),z.setFromAxisAngle(T,r),U(e,z,M),t.matrixWorld.premultiply(M),t.matrixWorld.decompose(t.position,t.quaternion,y)}_setFrame(t,e){const{up:i,camera:s,state:c,zoomPoint:a,zoomDirection:l,zoomDirectionSet:u,zoomPointSet:r,reorientOnDrag:m,scaleZoomOrientationAtEdges:g}=this;s.updateMatrixWorld(),z.setFromUnitVectors(i,t);const o=c;if(u&&(r||this._updateZoomPoint())){if(this.getUpDirection(a,y),g){let n=Math.max(y.dot(i)-.6,0)/.4;n=ht.mapLinear(n,0,.5,0,1),n=Math.min(n,1),s.isOrthographicCamera&&(n*=.1),z.slerp(mt,1-n)}U(a,z,M),s.matrixWorld.premultiply(M),s.matrixWorld.decompose(s.position,s.quaternion,y),l.subVectors(a,s.position).normalize()}else o===R&&m&&e&&(U(e,z,M),s.matrixWorld.premultiply(M),s.matrixWorld.decompose(s.position,s.quaternion,y));i.copy(t),s.updateMatrixWorld()}_raycast(t){const{scene:e,useFallbackPlane:i,fallbackPlane:s}=this,c=t.intersectObject(e)[0]||null;if(c)return c;if(i){const a=s;if(t.ray.intersectPlane(a,y))return{point:y.clone(),distance:t.ray.origin.distanceTo(y)}}return null}}export{gt as E,_ as N,yt as a,U as b,vt as c,b as m,E as s};
